# GDB 输出解读指南

本文档解释 GDB 调试时常见输出的含义。

---

## 1. 断点触发信息

```
Thread 1 "lock-server-deb" hit Breakpoint 2, main.(*Handler).Subscribe (...) at handler.go:148
```

**含义**：
- `Thread 1` - 线程1触发了断点
- `"lock-server-deb"` - 程序名称
- `hit Breakpoint 2` - 触发了第2个断点
- `main.(*Handler).Subscribe` - 当前函数（Go 的方法调用语法）
- `handler.go:148` - 断点位置（文件:行号）

---

## 2. `list` 命令输出

```
(gdb) list
143     }
144
145     // Subscribe 订阅资源操作完成事件（SSE）
146     func (h *Handler) Subscribe(w http.ResponseWriter, r *http.Request) {
147             // 解析查询参数
148             typeParam := r.URL.Query().Get("type")
149             resourceIDParam := r.URL.Query().Get("resource_id")
```

**含义**：
- 显示当前断点附近的代码
- 箭头 `=>` 指向当前执行的行（如果有）
- 帮助理解当前代码上下文

---

## 3. `info args` 命令输出

```
(gdb) info args
h = 0xc000118030
w = {tab = 0x8b6fb8 <go:itab.*net/http.response,net/http[ResponseWriter]>, data = 0xc0001720e0}
r = 0xc000162300
```

**含义**：
- `h = 0xc000118030` - Handler 指针的内存地址
- `w` - ResponseWriter 接口（Go 接口的内部表示）
  - `tab` - 接口表指针（指向类型信息）
  - `data` - 实际数据指针
- `r = 0xc000162300` - Request 指针的内存地址

**注意**：这些是内存地址，不是实际值。要查看实际内容，需要使用 `print` 命令。

---

## 4. `print` 命令输出

### 4.1 成功的情况

```
(gdb) p lockType
$2 = "pull"
(gdb) p resourceID
$3 = "sha256:test123"
```

**含义**：
- `$2`, `$3` - GDB 自动分配的变量编号（可以用于后续引用，如 `p $2`）
- `= "pull"` - 变量的实际值
- 字符串类型直接显示内容

### 4.2 失败的情况

```
(gdb) p lockType
No symbol "lockType" in current context.
```

**含义**：
- 当前作用域中没有 `lockType` 变量
- 可能原因：
  1. 变量还未声明（代码还没执行到那一行）
  2. 变量作用域已结束
  3. 当前不在正确的函数/作用域中

**解决方法**：
```bash
# 查看当前代码位置
(gdb) list

# 查看局部变量
(gdb) info locals

# 单步执行到变量声明处
(gdb) next
```

---

## 5. `info locals` 命令输出

### 5.1 正常情况

```
(gdb) info locals
typeParam = "pull"
resourceIDParam = "sha256:test123"
subscriber = 0xc00016d420
```

**含义**：
- 显示当前函数的所有局部变量
- 字符串显示实际值
- 指针显示内存地址

### 5.2 异常情况（内存读取错误）

```
(gdb) info locals
resourceIDParam = <error reading variable: Cannot access memory at address 0xf8>
typeParam = "\026\000\000\000\000zw"...
```

**含义**：
- `Cannot access memory` - 无法访问内存地址
- 可能原因：
  1. 变量还未初始化（代码还没执行到）
  2. 内存地址无效
  3. 编译器优化导致变量被优化掉

**解决方法**：
```bash
# 单步执行，让变量初始化
(gdb) next

# 或者直接打印变量（如果知道变量名）
(gdb) p typeParam
```

---

## 6. `backtrace` 命令输出

```
(gdb) backtrace
#0  main.(*Handler).Subscribe (...) at handler.go:148
#1  0x00000000007f3325 in main.(*Handler).Subscribe-fm (...) at <autogenerated>:1
#2  0x000000000078763a in net/http.HandlerFunc.ServeHTTP (...) at server.go:2141
#3  0x00000000007c6322 in github.com/gorilla/mux.(*Router).ServeHTTP (...) at mux.go:212
#4  0x000000000078ac57 in net/http.serverHandler.ServeHTTP (...) at server.go:2943
#5  0x00000000007867b9 in net/http.(*conn).serve (...) at server.go:2014
#6  0x000000000078ba3c in net/http.(*Server).Serve.func3 () at server.go:3091
#7  0x0000000000472601 in runtime.goexit () at asm_amd64.s:1650
```

**含义**：
- `#0` - 当前帧（最顶层，当前执行位置）
- `#1`, `#2` ... - 调用栈的层级（从内到外）
- 显示函数调用链：
  1. `Subscribe` - 你的代码
  2. `Subscribe-fm` - Go 编译器生成的包装函数
  3. `HandlerFunc.ServeHTTP` - HTTP 处理函数
  4. `Router.ServeHTTP` - 路由处理
  5. `serverHandler.ServeHTTP` - HTTP 服务器处理
  6. `conn.serve` - 连接处理
  7. `Server.Serve.func3` - 服务器 goroutine
  8. `runtime.goexit` - Go runtime 退出

**用途**：
- 理解代码执行路径
- 查看函数调用关系
- 定位问题来源

**切换帧**：
```bash
# 切换到上一级调用
(gdb) up
(gdb) frame 1

# 切换到下一级调用
(gdb) down
(gdb) frame 0

# 查看特定帧的变量
(gdb) frame 1
(gdb) info locals
```

---

## 7. `info frame` 命令输出

```
(gdb) info frame
Stack level 0, frame at 0xc00016d4b0:
 rip = 0x7edabd in main.(*Handler).Subscribe (handler.go:148); saved rip = 0x7f3325
 called by frame at 0xc00016d4e8
 source language unknown.
 Arglist at 0xc00016d368, args: h=0xc000118030, w=..., r=0xc000162300
 Locals at 0xc00016d368, Previous frame's sp is 0xc00016d4b0
 Saved registers:
  rip at 0xc00016d4a8
```

**含义**：
- `Stack level 0` - 当前栈帧级别
- `frame at 0xc00016d4b0` - 栈帧内存地址
- `rip = 0x7edabd` - 指令指针（当前执行地址）
- `saved rip = 0x7f3325` - 返回地址（函数返回后跳转的地址）
- `called by frame at 0xc00016d4e8` - 调用者的栈帧地址
- `Arglist at 0xc00016d368` - 参数列表的内存地址
- `Locals at 0xc00016d368` - 局部变量的内存地址

**用途**：
- 查看栈帧的详细信息
- 调试内存相关问题
- 理解函数调用机制

---

## 8. 打印 Go 接口

```
(gdb) p subscriber
$5 = {tab = 0x8b61e8 <go:itab.*main.SSESubscriber,main.Subscriber>, data = 0xc000164cf0}
```

**含义**：
- Go 接口的内部表示（包含两个字段）
- `tab` - 接口表指针（类型信息）
  - `go:itab.*main.SSESubscriber,main.Subscriber` - 表示 `*SSESubscriber` 实现了 `Subscriber` 接口
- `data` - 实际对象的指针

**查看接口的实际内容**：
```bash
# 查看接口指向的实际对象
(gdb) p subscriber.data
(gdb) p *((*main.SSESubscriber)(subscriber.data))

# 或者直接打印接口的值（GDB 会自动解引用）
(gdb) p subscriber
```

---

## 9. 访问 Go Map 的问题

```
(gdb) p shard.subscribers[key]
Can't do that binary op on that type
```

**含义**：
- GDB 无法直接使用 Go 的语法访问 map
- Go 的 map 是复杂的数据结构，需要特殊处理

**解决方法**：

```bash
# 方法1：使用 Go 的运行时函数（需要 Go 1.11+）
(gdb) p $m = runtime.mapaccess2_faststr(unsafe.Pointer(&shard.subscribers), unsafe.Pointer(&key), 0)
(gdb) p $m

# 方法2：查看 map 的内部结构
(gdb) p shard.subscribers
(gdb) p shard.subscribers.count  # map 的元素数量

# 方法3：使用 Go 的调试工具（推荐）
# 在代码中添加临时日志
log.Printf("Subscribers: %+v", shard.subscribers[key])
```

**更简单的方法**：
```bash
# 查看 map 的所有键值对（如果 map 很小）
(gdb) p shard.subscribers

# 或者使用 Go 的调试信息
(gdb) set print pretty on
(gdb) p shard.subscribers
```

---

## 10. 程序日志输出

```
2025/12/20 17:07:06 [Subscribe] 收到订阅请求: type=pull, resource_id=sha256:test123
2025/12/20 17:10:21 [Lock] 收到加锁请求: type=pull, resource_id=sha256:test123, node_id=node-1
2025/12/20 17:10:21 [TryLock] 直接获取锁成功: key=pull:sha256:test123, node=node-1
2025/12/20 17:10:21 [Lock] 成功加锁: resource_id=sha256:test123, node_id=node-1
2025/12/20 17:11:11 [Subscribe] 添加订阅者: key=pull:sha256:test123, 当前订阅者数量=1
```

**含义**：
- 这些是程序运行时输出的日志
- 即使程序停在断点处，之前执行的代码的日志也会显示
- 帮助理解程序的执行流程

**注意**：
- 日志输出和 GDB 断点是异步的
- 日志可能在断点触发之前或之后输出

---

## 11. `next` 命令执行后的输出

```
(gdb) next
2025/12/20 17:10:21 [Lock] 收到加锁请求: type=pull, resource_id=sha256:test123, node_id=node_id=node-1
...
276             key := LockKey(lockType, resourceID)
```

**含义**：
- `next` 执行后，程序继续执行下一行
- 日志输出显示程序在执行过程中产生的输出
- 最后一行显示当前代码位置（第276行）

---

## 12. Python Exception（GDB 内部错误）

```
Thread 1 "lock-server-deb" hit Breakpoint 1, main.(*LockManager).Subscribe (..., ~r0=Python Exception <class 'OverflowError'>: signed integer is greater than maximum
```

**含义**：
- GDB 使用 Python 来处理某些 Go 类型
- 这个错误是 GDB 内部的 Python 异常，不影响调试
- 通常出现在打印返回值时（`~r0` 表示返回值）

**解决方法**：
```bash
# 忽略这个错误，继续调试
(gdb) continue

# 或者直接打印变量，不使用返回值
(gdb) p lockType
(gdb) p resourceID
```

---

## 13. 线程创建信息

```
[New Thread 0x7fffaa7fc6c0 (LWP 3406530)]
```

**含义**：
- Go 程序创建了新的 goroutine（映射为系统线程）
- `0x7fffaa7fc6c0` - 线程栈地址
- `LWP 3406530` - 轻量级进程ID（Linux线程ID）

**说明**：
- Go 的 goroutine 可能映射到系统线程
- HTTP 服务器会为每个请求创建 goroutine
- 这是正常现象

---

## 实用调试技巧总结

### 1. 查看变量值的正确方法

```bash
# 字符串类型
(gdb) p typeParam
$1 = "pull"

# 指针类型
(gdb) p subscriber
$2 = 0xc00016d420

# 结构体类型
(gdb) p *request
$3 = {Type = "pull", ResourceID = "sha256:test123", ...}

# 接口类型
(gdb) p subscriber
$4 = {tab = ..., data = ...}
```

### 2. 理解调用栈

```bash
# 查看完整调用栈
(gdb) backtrace

# 切换到上一级调用
(gdb) up
(gdb) info locals

# 切换回当前帧
(gdb) down
```

### 3. 处理无法访问的变量

```bash
# 如果变量还未初始化，单步执行
(gdb) next

# 如果变量作用域已结束，切换到正确的帧
(gdb) frame N
(gdb) info locals
```

### 4. 调试 Go 特有类型

```bash
# Map - 使用运行时函数或添加日志
(gdb) p shard.subscribers  # 查看 map 结构

# Channel - 查看内部结构
(gdb) p channel

# Interface - 查看 tab 和 data
(gdb) p interface_var
(gdb) p interface_var.data
```

---

## 常见问题解答

### Q1: 为什么 `info locals` 显示乱码？

**A**: 变量还未初始化，内存中是无意义的数据。使用 `next` 执行到变量初始化后再查看。

### Q2: 为什么无法访问 map？

**A**: GDB 对 Go 的 map 支持有限。建议在代码中添加日志，或使用 Delve 调试器（Go 专用）。

### Q3: Python Exception 会影响调试吗？

**A**: 不会。这是 GDB 内部的错误，不影响实际调试。可以忽略。

### Q4: 如何查看 Go 结构体的所有字段？

**A**: 
```bash
(gdb) set print pretty on
(gdb) p struct_var
```

### Q5: 如何查看 slice 的内容？

**A**:
```bash
(gdb) p slice_var
(gdb) p slice_var.len
(gdb) p slice_var.array[0]
```

---

## 参考资源

- [GDB 官方文档](https://sourceware.org/gdb/documentation/)
- [Go 调试指南](https://golang.org/doc/diagnostics.html)
- [Delve 调试器](https://github.com/go-delve/delve) - Go 专用调试器（推荐）

