# 锁的目的和实现分析

## 问题分析

### 用户观察到的现象

1. **节点B和节点C同时下载同一个镜像层**
   - 资源ID: `sha256:865b95f46d98cf867a156fe4a135ad3fe50d2056aa3f25ed31662dff6da4eb62`
   - 节点B先获取锁
   - 节点C加入等待队列，一直轮询

2. **节点C阻塞**
   - 节点C在等待队列中，持续轮询 `/lock/status`
   - 返回 `acquired=false, completed=false, success=false`

3. **疑问**
   - 是否没有实现一个镜像的多个层可以给不同的节点并发下载？
   - 锁的目的是什么？

## 锁的目的 ✅

### 1. 防止重复下载（同一层）

**目的**：确保**同一个镜像层**（相同的 `resource_id`）只能被**一个节点**下载。

**原因**：
- 避免多个节点同时下载同一个层，造成带宽浪费
- 避免多个节点同时写入同一个文件，造成文件损坏
- 通过 `mergerfs` 共享，一个节点下载后，其他节点可以直接使用

**实现**：
- 锁的粒度：`type:resource_id`
- 同一个 `resource_id` 只能被一个节点持有锁

### 2. 允许并发下载（不同层）

**目的**：**不同的镜像层**（不同的 `resource_id`）可以被**不同的节点**并发下载。

**原因**：
- 提高下载效率
- 充分利用多节点资源
- 镜像通常有多个层，可以并行下载

**实现**：
- 每个层有不同的 `resource_id`（digest）
- 不同的 `resource_id` 对应不同的锁
- 不同的锁可以并发获取

### 3. 通过轮询发现操作已完成

**目的**：如果操作已完成且成功，等待的节点应该跳过操作。

**原因**：
- 避免重复下载
- 提高效率

**实现**：
- 操作成功时，锁标记为 `completed=true, success=true`
- 等待的节点通过轮询 `/lock/status` 发现操作已完成
- 返回 `skipped=true`，跳过操作

## 从日志分析

### 日志时间线

```
14:18:05 - 节点B请求锁 sha256:865b95f46d98cf867a156fe4a135ad3fe50d2056aa3f25ed31662dff6da4eb62
           → 获取锁成功 ✅

14:18:06 - 节点C请求锁 sha256:865b95f46d98cf867a156fe4a135ad3fe50d2056aa3f25ed31662dff6da4eb62
           → 加入等待队列 ✅（正确：同一层，必须等待）

14:18:06-14:18:28 - 节点C持续轮询
           → acquired=false, completed=false, success=false ✅（正确：节点B还在操作）

14:18:28 - 节点B操作失败，释放锁
           → success=false ✅

14:18:28 - 节点C获得锁
           → acquired=true ✅（正确：节点B失败后，节点C获得锁）

14:18:28 - 节点B开始下载其他层：
           → sha256:1882fa4569e0c591ea092d3766c4893e19b8901a8e649de7067188aba3cc0679 ✅
           → sha256:e7b39c54cdeca0d2aae83114bb605753a5f5bc511fe8be7590e38f6d9f915dad ✅
           → sha256:1074353eec0db2c1d81d5af2671e56e00cf5738486f5762609ea33d606f88612 ✅
           → 这些是不同的层，可以并发下载 ✅

14:18:51 - 节点C操作失败，释放锁
           → success=false ✅

14:18:51 - 节点C请求另一个层 sha256:1074353eec0db2c1d81d5af2671e56e00cf5738486f5762609ea33d606f88612
           → 加入等待队列 ✅（正确：节点B正在下载这个层）
```

### 关键发现 ✅

1. **多层并发下载已实现** ✅
   - 节点B在下载多个不同的层
   - 这些层有不同的 `resource_id`
   - 不同的层可以被不同的节点并发下载

2. **同一层串行下载** ✅
   - 节点B和节点C请求同一个层 `sha256:865b95f46d98cf867a156fe4a135ad3fe50d2056aa3f25ed31662dff6da4eb62`
   - 节点C必须等待节点B完成
   - 这是**正确的行为**

3. **节点C没有一直阻塞** ✅
   - 节点B操作失败后，节点C获得了锁
   - 节点C也操作失败，释放锁
   - 节点C没有一直阻塞，而是获得了锁但操作失败了

## 为什么节点C看起来"一直阻塞"？

### 原因分析

1. **节点B操作时间较长**
   - 节点B从 14:18:05 开始操作
   - 到 14:18:28 才释放锁（约23秒）
   - 节点C在这23秒内一直在轮询等待

2. **节点C操作也失败**
   - 节点C获得锁后，操作也失败
   - 这可能是因为：
     - 网络问题
     - 资源不存在
     - 其他错误

3. **轮询机制正常工作**
   - 节点C每500ms轮询一次
   - 在节点B释放锁后，节点C立即获得了锁
   - 轮询机制正常工作 ✅

## 锁的粒度

### 当前实现

```go
// server/types.go
func LockKey(lockType, resourceID string) string {
    return lockType + ":" + resourceID
}
```

**锁的粒度**：`type:resource_id`

**示例**：
- `pull:sha256:865b95f46d98cf867a156fe4a135ad3fe50d2056aa3f25ed31662dff6da4eb62`
- `pull:sha256:1882fa4569e0c591ea092d3766c4893e19b8901a8e649de7067188aba3cc0679`
- `pull:sha256:e7b39c54cdeca0d2aae83114bb605753a5f5bc511fe8be7590e38f6d9f915dad`

**结果**：
- ✅ 同一个层（相同的 `resource_id`）只能被一个节点下载
- ✅ 不同的层（不同的 `resource_id`）可以被不同的节点并发下载

## 验证多层并发下载

### 测试场景

**场景1：同一层，不同节点**
```
节点A请求: pull:sha256:layer1 → 获取锁 ✅
节点B请求: pull:sha256:layer1 → 加入队列 ✅（必须等待）
节点A完成 → 节点B获得锁 ✅
```

**场景2：不同层，不同节点**
```
节点A请求: pull:sha256:layer1 → 获取锁 ✅
节点B请求: pull:sha256:layer2 → 获取锁 ✅（可以并发）
节点C请求: pull:sha256:layer3 → 获取锁 ✅（可以并发）
```

### 从日志验证 ✅

从日志可以看到：
- 节点B在下载多个不同的层：
  - `sha256:865b95f46d98cf867a156fe4a135ad3fe50d2056aa3f25ed31662dff6da4eb62`
  - `sha256:1882fa4569e0c591ea092d3766c4893e19b8901a8e649de7067188aba3cc0679`
  - `sha256:e7b39c54cdeca0d2aae83114bb605753a5f5bc511fe8be7590e38f6d9f915dad`
  - `sha256:1074353eec0db2c1d81d5af2671e56e00cf5738486f5762609ea33d606f88612`

**这些是不同的层，可以被不同的节点并发下载** ✅

## 总结

### 锁的目的 ✅

1. **防止重复下载（同一层）**
   - 同一个镜像层只能被一个节点下载
   - 避免带宽浪费和文件损坏

2. **允许并发下载（不同层）**
   - 不同的镜像层可以被不同的节点并发下载
   - 提高下载效率

3. **通过轮询发现操作已完成**
   - 如果操作已完成且成功，等待的节点应该跳过操作
   - 避免重复下载

### 当前实现 ✅

- ✅ 锁的粒度：`type:resource_id`
- ✅ 同一个层串行下载
- ✅ 不同的层并发下载
- ✅ 轮询机制正常工作

### 节点C的行为 ✅

- ✅ 节点C没有一直阻塞
- ✅ 节点C在节点B失败后获得了锁
- ✅ 节点C操作失败，释放锁
- ✅ 节点C可以请求其他层（如 `sha256:1074353eec0db2c1d81d5af2671e56e00cf5738486f5762609ea33d606f88612`）

### 建议

如果节点C的操作一直失败，需要检查：
1. 网络连接
2. 资源是否存在
3. 错误日志
4. 是否需要重试机制

