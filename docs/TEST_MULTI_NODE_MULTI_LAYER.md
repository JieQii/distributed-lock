# 测试场景：节点A和节点B同时下载四个镜像层

## 测试目的

模拟节点A和节点B同时请求下载四个镜像层，观察锁的分配过程和并发下载行为。

## 测试场景

### 场景设置

- **节点A**: 先开始下载（提前200ms）
- **节点B**: 稍后开始下载
- **四个镜像层**:
  - Layer1: 3秒
  - Layer2: 2秒
  - Layer3: 4秒
  - Layer4: 2秒

### 预期行为

1. **节点A先请求所有层**
   - Layer1: 获得锁 ✅
   - Layer2: 获得锁 ✅
   - Layer3: 获得锁 ✅
   - Layer4: 获得锁 ✅

2. **节点B后请求所有层**
   - Layer1: 加入等待队列 ⏳（节点A正在下载）
   - Layer2: 加入等待队列 ⏳（节点A正在下载）
   - Layer3: 加入等待队列 ⏳（节点A正在下载）
   - Layer4: 加入等待队列 ⏳（节点A正在下载）

3. **节点A完成下载**
   - Layer2完成（2秒）→ 节点B从队列获得锁，开始下载
   - Layer4完成（2秒）→ 节点B从队列获得锁，开始下载
   - Layer1完成（3秒）→ 节点B通过轮询发现已完成，跳过下载
   - Layer3完成（4秒）→ 节点B从队列获得锁，开始下载

## 运行测试

### 1. 启动服务器

```bash
cd server
go run main.go
```

服务器会在 `http://127.0.0.1:8080` 启动，并输出详细的锁分配日志。

### 2. 运行测试程序

在另一个终端运行：

```bash
go run test-multi-node-multi-layer.go
```

## 日志说明

### 服务器端日志

- `[Lock] 🔒 收到加锁请求`: 收到锁请求
- `[TryLock] ✅ 直接获取锁成功`: 成功获取锁
- `[TryLock] ⏳ 加入等待队列`: 加入等待队列
- `[Unlock] ✅ 操作成功`: 操作成功，保留锁信息
- `[processQueue] 🔄 从队列分配锁`: 从队列分配锁给下一个节点
- `[LockStatus] 🔍 查询锁状态`: 查询锁状态

### 客户端日志

- `📋 请求层的锁`: 请求锁
- `🔒 层锁响应`: 锁响应结果
- `✅ 获得层的锁`: 获得锁
- `⏳ 层未获得锁，进入轮询等待`: 进入轮询等待
- `🔍 轮询层状态`: 轮询状态
- `⏭️ 层已由其他节点完成，跳过下载`: 跳过下载
- `🚀 开始下载层`: 开始下载
- `✅ 层下载完成`: 下载完成
- `🔓 释放层的锁`: 释放锁

## 锁分配过程示例

```
时间线：

T0: 节点A请求Layer1 → 获得锁 ✅
T0: 节点A请求Layer2 → 获得锁 ✅
T0: 节点A请求Layer3 → 获得锁 ✅
T0: 节点A请求Layer4 → 获得锁 ✅

T0.2: 节点B请求Layer1 → 加入等待队列 ⏳
T0.2: 节点B请求Layer2 → 加入等待队列 ⏳
T0.2: 节点B请求Layer3 → 加入等待队列 ⏳
T0.2: 节点B请求Layer4 → 加入等待队列 ⏳

T2: 节点A完成Layer2 → 释放锁 ✅
    → 节点B从队列获得Layer2的锁，开始下载

T2: 节点A完成Layer4 → 释放锁 ✅
    → 节点B从队列获得Layer4的锁，开始下载

T3: 节点A完成Layer1 → 释放锁（成功）✅
    → 节点B轮询发现Layer1已完成，跳过下载

T4: 节点A完成Layer3 → 释放锁 ✅
    → 节点B从队列获得Layer3的锁，开始下载
```

## 关键观察点

1. **锁的分配**
   - 先到先得：节点A先请求，获得所有层的锁
   - 队列机制：节点B的请求加入等待队列

2. **并发下载**
   - 不同层使用不同的锁
   - 节点A可以同时下载多个层
   - 节点B在等待时，可以并发下载其他层（如果获得锁）

3. **轮询机制**
   - 节点B通过轮询发现Layer1已完成
   - 自动跳过已完成的层

4. **队列处理**
   - FIFO顺序：先加入队列的请求先获得锁
   - 操作失败时，锁转交给队列中的下一个节点

## 测试输出示例

```
2025/12/18 15:00:00.000000 ==========================================
2025/12/18 15:00:00.000000 测试场景：节点A和节点B同时下载四个镜像层
2025/12/18 15:00:00.000000 ==========================================
2025/12/18 15:00:00.000000 ✅ 服务器运行正常
2025/12/18 15:00:00.000000 
2025/12/18 15:00:00.000000 📦 镜像层列表:
2025/12/18 15:00:00.000000   层1: sha256:layer1 (预计耗时: 3s)
2025/12/18 15:00:00.000000   层2: sha256:layer2 (预计耗时: 2s)
2025/12/18 15:00:00.000000   层3: sha256:layer3 (预计耗时: 4s)
2025/12/18 15:00:00.000000   层4: sha256:layer4 (预计耗时: 2s)
2025/12/18 15:00:00.000000 
2025/12/18 15:00:00.000000 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2025/12/18 15:00:00.000000 节点A开始下载...
2025/12/18 15:00:00.000000 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2025/12/18 15:00:00.100000 [NODEA] 📋 请求层 sha256:layer1 的锁...
2025/12/18 15:00:00.100000 [NODEA] 📋 请求层 sha256:layer2 的锁...
2025/12/18 15:00:00.100000 [NODEA] 📋 请求层 sha256:layer3 的锁...
2025/12/18 15:00:00.100000 [NODEA] 📋 请求层 sha256:layer4 的锁...
...
```

## 总结

这个测试场景展示了：

1. ✅ **锁的分配机制**：先到先得，后到的加入队列
2. ✅ **并发下载能力**：不同层可以并发下载
3. ✅ **队列处理机制**：FIFO顺序，操作完成后转交给队列
4. ✅ **轮询跳过机制**：通过轮询发现操作已完成，自动跳过

