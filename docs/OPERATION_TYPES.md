# 操作类型（服务器职责简版）

> 当前设计：**服务器只负责锁的互斥与排队，不再做引用计数判断**；引用计数与“做/不做”由 Content 插件在本地借助 `callback` 包完成。

## 操作类型

- **pull**：拉取镜像层，服务器仅保证互斥；是否需要拉取由内容侧基于本地计数判断。
- **update**：更新镜像层，服务器仅保证互斥，不关心引用计数或热更新开关。
- **delete**：删除镜像层，服务器仅保证互斥，不做“refcount == 0”检查；是否能删由业务侧判断。

## 锁行为（服务器）

- 锁键：`Type + ":" + ResourceID`。不同类型同一资源视为不同逻辑锁。
- 仲裁流程：
  1) 若已有锁且未完成 → 进入队列（FIFO）；  
  2) 若已有锁且已完成 → 清理并推进队列；  
  3) 无锁 → 直接获得锁。  
  返回值仅包含 `acquired`，`skip` 保留为兼容字段但恒为 `false`。
- 解锁：校验持有者，删除锁，处理等待队列。

## 引用计数（已移出服务器）

- 服务器不再维护/返回引用计数，也没有 `/refcount` 接口。
- Content 插件可用 `callback.RefCountManager` + 自定义存储（如本地文件/DB）在获取锁前后自行判断与更新。

## 建议的业务侧流程（示例）

1. Content 插件使用 `callback.ShouldSkipOperation` 判断是否需要执行；决定跳过则不请求锁。  
2. 需要执行时再调用客户端 `Lock()` 获取服务器锁。  
3. 操作成功后，调用 `callback.UpdateRefCount` 更新本地计数，然后调用服务器 `/unlock` 释放锁。

