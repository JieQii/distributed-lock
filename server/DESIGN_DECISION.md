# 设计决策：引用计数判断逻辑的位置

## 问题

根据引用计数判断 content 插件是否要做这个操作，这个判断逻辑是否应该放到分布式锁服务端来做？

## 当前设计

**判断逻辑在分布式锁服务端**：

1. **服务端判断**（`server/lock_manager.go`）：
   - 在 `TryLock` 方法中，服务端根据引用计数判断是否应该跳过操作
   - Pull: `refcount != 0` → 返回 `skip = true`
   - Delete: `refcount > 0` → 返回错误
   - Update: 根据配置决定

2. **服务端返回**（`server/handler.go`）：
   ```go
   acquired, skip, errMsg := h.lockManager.TryLock(&request)
   response := map[string]interface{}{
       "acquired": acquired,
       "skip":     skip,  // 服务端告诉客户端是否应该跳过
   }
   ```

3. **客户端处理**（`client/client.go`）：
   ```go
   if lockResp.Skip {
       return &LockResult{
           Acquired: false,
           Skipped:  true,  // 客户端传递跳过标志
       }, nil
   }
   ```

4. **Content插件响应**（`content/writer.go`）：
   ```go
   if result.Skipped {
       writer.skipped = true  // Content插件根据服务端的判断跳过操作
       writer.locked = false
   }
   ```

## 设计决策分析

### 方案A：判断逻辑在服务端（当前方案）✅

**优点**：
1. **集中管理**：所有节点使用相同的判断逻辑，避免重复实现
2. **数据一致性**：引用计数信息在服务端，服务端有完整信息做判断
3. **减少网络请求**：客户端不需要额外查询引用计数
4. **原子性**：判断和锁获取在同一个操作中完成，避免竞态条件
5. **简化客户端**：客户端只需要根据服务端的指示执行，不需要了解业务逻辑

**缺点**：
1. **服务端耦合业务逻辑**：服务端需要了解"什么时候应该跳过操作"
2. **扩展性**：如果不同业务场景有不同的跳过规则，服务端需要支持更多配置

### 方案B：判断逻辑在客户端/Content插件

**优点**：
1. **职责分离**：服务端只负责锁管理，业务逻辑在业务层
2. **灵活性**：不同业务场景可以实现不同的判断逻辑
3. **解耦**：服务端不需要了解业务语义

**缺点**：
1. **重复实现**：每个客户端都需要实现相同的判断逻辑
2. **数据不一致风险**：客户端需要查询引用计数，可能存在时间差
3. **额外网络请求**：客户端需要先查询引用计数，再决定是否获取锁
4. **竞态条件**：查询引用计数和获取锁之间存在时间窗口，可能导致判断错误
5. **客户端复杂度增加**：客户端需要理解业务逻辑

## 推荐方案：方案A（当前方案）

### 理由

1. **引用计数是锁状态的一部分**：
   - 引用计数反映了资源的当前使用状态
   - 这个状态是分布式锁系统维护的，应该由锁系统来判断

2. **避免竞态条件**：
   - 如果判断在客户端，可能出现：
     - 客户端A查询引用计数 = 0，决定获取锁
     - 客户端B同时查询引用计数 = 0，也决定获取锁
     - 两个客户端都尝试获取锁，导致重复操作
   - 在服务端判断可以保证原子性

3. **简化业务层**：
   - Content插件不需要了解引用计数的业务含义
   - 只需要根据服务端的指示执行：`skip = true` 就跳过，`acquired = true` 就执行

4. **一致性保证**：
   - 所有节点使用相同的判断逻辑
   - 避免不同节点实现不一致导致的bug

## 当前实现的判断逻辑

### Pull操作
```go
case OperationTypePull:
    // 如果refcount != 0，说明已经下载完成（但还没刷新mergerfs），应该跳过
    if refCount.Count > 0 {
        return false, true, "" // skip = true
    }
```
**语义**：如果引用计数 > 0，说明资源已经被其他节点下载完成，当前节点应该跳过下载。

### Delete操作
```go
case OperationTypeDelete:
    // 如果refcount > 0，不能执行delete操作（有节点在使用）
    if refCount.Count > 0 {
        return false, false, "无法删除：当前有节点正在使用该资源"
    }
```
**语义**：如果引用计数 > 0，说明有节点正在使用资源，不能删除。

### Update操作
```go
case OperationTypeUpdate:
    // 如果配置要求UpdateRequiresNoRef且refcount > 0，不能执行update操作
    if lm.UpdateRequiresNoRef && refCount.Count > 0 {
        return false, false, "无法更新：当前有节点正在使用该资源，不允许更新"
    }
```
**语义**：根据配置决定是否允许在有引用时更新（热更新）。

## 总结

**当前设计是合理的**，判断逻辑应该放在分布式锁服务端：

1. ✅ **原子性**：判断和锁获取在同一操作中，避免竞态条件
2. ✅ **一致性**：所有节点使用相同的判断逻辑
3. ✅ **简化客户端**：客户端不需要了解业务逻辑
4. ✅ **数据准确性**：服务端有最新的引用计数信息

**Content插件只需要**：
- 根据服务端返回的 `skip` 标志决定是否执行操作
- 不需要查询或理解引用计数的含义
- 保持简单和专注：只负责执行或跳过操作

## 如果未来需要更灵活的判断逻辑

如果未来需要支持更复杂的判断规则，可以考虑：

1. **配置化**：在服务端通过配置支持不同的判断规则
2. **插件化**：服务端支持自定义判断逻辑插件
3. **混合方案**：服务端提供基础判断，客户端可以覆盖（但需要明确文档说明）

但目前的设计已经能够满足需求，建议保持当前方案。

