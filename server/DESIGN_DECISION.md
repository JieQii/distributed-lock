# 设计决策：引用计数判断位置

## 结论

- **服务器**：只负责分布式锁的互斥与排队，不再依据引用计数决定“跳过/拒绝”。
- **Content 插件**：在业务侧使用 `callback` 包 + 本地存储（文件/DB）判断“做/不做”，并维护引用计数。
- **理由**：职责分离、避免服务端耦合业务语义、减少竞态窗口（判断与计数在同一进程内完成）、客户端逻辑可按业务自定义。

## 对照：旧方案 vs 现方案

|            | 旧方案（服务器判断） | 现方案（业务侧判断） |
|------------|---------------------|----------------------|
| 判断位置   | TryLock 内根据 refcount 决定 skip/error | Content 插件用 callback 先判再锁 |
| skip 字段  | 服务器置位返回      | 始终 false（仅兼容保留） |
| /refcount  | 提供查询接口        | 已移除 |
| UpdateRequiresNoRef | 支持配置     | 移除 |
| 复杂度     | 服务器高、耦合业务   | 服务器简化，业务自控 |

## 推荐使用方式（业务侧）

1) `callback.ShouldSkipOperation` 判断是否需要执行；skip 则不请求锁。  
2) 需要执行时再调用服务器锁接口获取互斥。  
3) 操作成功后调用 `callback.UpdateRefCount` 更新本地计数，再 `/unlock` 释放锁。  
4) 计数持久化可自定义（本地文件/DB/外部存储）。

## 影响面

- 代码：`server/lock_manager.go` 不再使用 refcount 逻辑；`skip` 恒为 false。  
- 协议：保留 `skip` 字段兼容旧客户端，但意义由业务侧自行决定。  
- 文档：已移除 `/refcount` 接口及服务端引用计数描述。

